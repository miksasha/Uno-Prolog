{"version":3,"file":"next-query-params.cjs.production.min.js","sources":["../src/NextAdapter.tsx"],"sourcesContent":["import {useRouter} from 'next/router';\nimport {memo, ReactElement, useMemo} from 'react';\nimport {PartialLocation, QueryParamAdapter} from 'use-query-params';\n\nconst pathnameRegex = /[^?#]+/u;\n\ntype Props = {\n  shallow?: boolean;\n  children(adapter: QueryParamAdapter): ReactElement | null;\n};\n\nfunction NextAdapter({children, shallow = true}: Props) {\n  const router = useRouter();\n  const match = router.asPath.match(pathnameRegex);\n  const pathname = match ? match[0] : router.asPath;\n\n  const location = useMemo(() => {\n    if (typeof window !== 'undefined') {\n      // For SSG, no query parameters are available on the server side,\n      // since they can't be known at build time. Therefore to avoid\n      // markup mismatches, we need a two-part render in this case that\n      // patches the client with the updated query parameters lazily.\n      // Note that for SSR `router.isReady` will be `true` immediately\n      // and therefore there's no two-part render in this case.\n      if (router.isReady) {\n        return window.location;\n      } else {\n        return {search: ''} as Location;\n      }\n    } else {\n      // On the server side we only need a subset of the available\n      // properties of `Location`. The other ones are only necessary\n      // for interactive features on the client.\n      return {search: router.asPath.replace(pathnameRegex, '')} as Location;\n    }\n  }, [router.asPath, router.isReady]);\n\n  const adapter: QueryParamAdapter = useMemo(() => {\n    function createUpdater(routeFn: typeof router.push) {\n      return function updater({\n        hash,\n        search\n      }: PartialLocation & {hash?: string}) {\n        routeFn(\n          {pathname: router.pathname, search, hash},\n          {pathname, search, hash},\n          {shallow, scroll: false}\n        );\n      };\n    }\n\n    return {\n      push: createUpdater(router.push),\n      replace: createUpdater(router.replace),\n      location\n    };\n  }, [location, pathname, router, shallow]);\n\n  return children(adapter);\n}\n\nexport default memo(NextAdapter);\n"],"names":["pathnameRegex","NextAdapter","children","shallow","router","useRouter","match","asPath","pathname","location","useMemo","window","isReady","search","replace","createUpdater","routeFn","hash","scroll","push","memo"],"mappings":"oHAIMA,EAAgB,uBAOtB,SAASC,SAAaC,IAAAA,aAAUC,QAAAA,gBACxBC,EAASC,cACTC,EAAQF,EAAOG,OAAOD,MAAMN,GAC5BQ,EAAWF,EAAQA,EAAM,GAAKF,EAAOG,OAErCE,EAAWC,WAAQ,iBACD,oBAAXC,OAOLP,EAAOQ,QACFD,OAAOF,SAEP,CAACI,OAAQ,IAMX,CAACA,OAAQT,EAAOG,OAAOO,QAAQd,EAAe,OAEtD,CAACI,EAAOG,OAAQH,EAAOQ,iBAuBnBV,EArB4BQ,WAAQ,oBAChCK,EAAcC,UACd,gBACLC,IAAAA,KACAJ,IAAAA,OAEAG,EACE,CAACR,SAAUJ,EAAOI,SAAUK,OAAAA,EAAQI,KAAAA,GACpC,CAACT,SAAAA,EAAUK,OAAAA,EAAQI,KAAAA,GACnB,CAACd,QAAAA,EAASe,QAAQ,WAKjB,CACLC,KAAMJ,EAAcX,EAAOe,MAC3BL,QAASC,EAAcX,EAAOU,SAC9BL,SAAAA,KAED,CAACA,EAAUD,EAAUJ,EAAQD,yBAKnBiB,OAAKnB"}