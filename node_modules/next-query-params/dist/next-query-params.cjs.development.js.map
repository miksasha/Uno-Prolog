{"version":3,"file":"next-query-params.cjs.development.js","sources":["../src/NextAdapter.tsx"],"sourcesContent":["import {useRouter} from 'next/router';\nimport {memo, ReactElement, useMemo} from 'react';\nimport {PartialLocation, QueryParamAdapter} from 'use-query-params';\n\nconst pathnameRegex = /[^?#]+/u;\n\ntype Props = {\n  shallow?: boolean;\n  children(adapter: QueryParamAdapter): ReactElement | null;\n};\n\nfunction NextAdapter({children, shallow = true}: Props) {\n  const router = useRouter();\n  const match = router.asPath.match(pathnameRegex);\n  const pathname = match ? match[0] : router.asPath;\n\n  const location = useMemo(() => {\n    if (typeof window !== 'undefined') {\n      // For SSG, no query parameters are available on the server side,\n      // since they can't be known at build time. Therefore to avoid\n      // markup mismatches, we need a two-part render in this case that\n      // patches the client with the updated query parameters lazily.\n      // Note that for SSR `router.isReady` will be `true` immediately\n      // and therefore there's no two-part render in this case.\n      if (router.isReady) {\n        return window.location;\n      } else {\n        return {search: ''} as Location;\n      }\n    } else {\n      // On the server side we only need a subset of the available\n      // properties of `Location`. The other ones are only necessary\n      // for interactive features on the client.\n      return {search: router.asPath.replace(pathnameRegex, '')} as Location;\n    }\n  }, [router.asPath, router.isReady]);\n\n  const adapter: QueryParamAdapter = useMemo(() => {\n    function createUpdater(routeFn: typeof router.push) {\n      return function updater({\n        hash,\n        search\n      }: PartialLocation & {hash?: string}) {\n        routeFn(\n          {pathname: router.pathname, search, hash},\n          {pathname, search, hash},\n          {shallow, scroll: false}\n        );\n      };\n    }\n\n    return {\n      push: createUpdater(router.push),\n      replace: createUpdater(router.replace),\n      location\n    };\n  }, [location, pathname, router, shallow]);\n\n  return children(adapter);\n}\n\nexport default memo(NextAdapter);\n"],"names":["pathnameRegex","NextAdapter","children","shallow","router","useRouter","match","asPath","pathname","location","useMemo","window","isReady","search","replace","adapter","createUpdater","routeFn","updater","hash","scroll","push","memo"],"mappings":";;;;;;;AAIA,IAAMA,aAAa,GAAG,sBAAtB;;AAOA,SAASC,WAAT;MAAsBC,gBAAAA;0BAAUC;MAAAA,oCAAU;AACxC,MAAMC,QAAM,GAAGC,gBAAS,EAAxB;AACA,MAAMC,KAAK,GAAGF,QAAM,CAACG,MAAP,CAAcD,KAAd,CAAoBN,aAApB,CAAd;AACA,MAAMQ,QAAQ,GAAGF,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAcF,QAAM,CAACG,MAA3C;AAEA,MAAME,QAAQ,GAAGC,aAAO,CAAC;AACvB,QAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,UAAIP,QAAM,CAACQ,OAAX,EAAoB;AAClB,eAAOD,MAAM,CAACF,QAAd;AACD,OAFD,MAEO;AACL,eAAO;AAACI,UAAAA,MAAM,EAAE;AAAT,SAAP;AACD;AACF,KAZD,MAYO;AACL;AACA;AACA;AACA,aAAO;AAACA,QAAAA,MAAM,EAAET,QAAM,CAACG,MAAP,CAAcO,OAAd,CAAsBd,aAAtB,EAAqC,EAArC;AAAT,OAAP;AACD;AACF,GAnBuB,EAmBrB,CAACI,QAAM,CAACG,MAAR,EAAgBH,QAAM,CAACQ,OAAvB,CAnBqB,CAAxB;AAqBA,MAAMG,OAAO,GAAsBL,aAAO,CAAC;AACzC,aAASM,aAAT,CAAuBC,OAAvB;AACE,aAAO,SAASC,OAAT;YACLC,aAAAA;YACAN,eAAAA;AAEAI,QAAAA,OAAO,CACL;AAACT,UAAAA,QAAQ,EAAEJ,QAAM,CAACI,QAAlB;AAA4BK,UAAAA,MAAM,EAANA,MAA5B;AAAoCM,UAAAA,IAAI,EAAJA;AAApC,SADK,EAEL;AAACX,UAAAA,QAAQ,EAARA,QAAD;AAAWK,UAAAA,MAAM,EAANA,MAAX;AAAmBM,UAAAA,IAAI,EAAJA;AAAnB,SAFK,EAGL;AAAChB,UAAAA,OAAO,EAAPA,OAAD;AAAUiB,UAAAA,MAAM,EAAE;AAAlB,SAHK,CAAP;AAKD,OATD;AAUD;;AAED,WAAO;AACLC,MAAAA,IAAI,EAAEL,aAAa,CAACZ,QAAM,CAACiB,IAAR,CADd;AAELP,MAAAA,OAAO,EAAEE,aAAa,CAACZ,QAAM,CAACU,OAAR,CAFjB;AAGLL,MAAAA,QAAQ,EAARA;AAHK,KAAP;AAKD,GAnByC,EAmBvC,CAACA,QAAD,EAAWD,QAAX,EAAqBJ,QAArB,EAA6BD,OAA7B,CAnBuC,CAA1C;AAqBA,SAAOD,QAAQ,CAACa,OAAD,CAAf;AACD;;AAED,iCAAeO,UAAI,CAACrB,WAAD,CAAnB;;;;"}